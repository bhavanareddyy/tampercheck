// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'error_report_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ErrorReportStateTearOff {
  const _$ErrorReportStateTearOff();

  ErrorReportStateInitial initial() {
    return const ErrorReportStateInitial();
  }

  ErrorReportStateInProgress inProgress() {
    return const ErrorReportStateInProgress();
  }

  ErrorReportStateSuccess success() {
    return const ErrorReportStateSuccess();
  }

  ErrorReportStateEmailUnsupported emailUnsupported() {
    return const ErrorReportStateEmailUnsupported();
  }
}

/// @nodoc
const $ErrorReportState = _$ErrorReportStateTearOff();

/// @nodoc
mixin _$ErrorReportState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function() success,
    required TResult Function() emailUnsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorReportStateInitial value) initial,
    required TResult Function(ErrorReportStateInProgress value) inProgress,
    required TResult Function(ErrorReportStateSuccess value) success,
    required TResult Function(ErrorReportStateEmailUnsupported value)
        emailUnsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorReportStateCopyWith<$Res> {
  factory $ErrorReportStateCopyWith(
          ErrorReportState value, $Res Function(ErrorReportState) then) =
      _$ErrorReportStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorReportStateCopyWithImpl<$Res>
    implements $ErrorReportStateCopyWith<$Res> {
  _$ErrorReportStateCopyWithImpl(this._value, this._then);

  final ErrorReportState _value;
  // ignore: unused_field
  final $Res Function(ErrorReportState) _then;
}

/// @nodoc
abstract class $ErrorReportStateInitialCopyWith<$Res> {
  factory $ErrorReportStateInitialCopyWith(ErrorReportStateInitial value,
          $Res Function(ErrorReportStateInitial) then) =
      _$ErrorReportStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorReportStateInitialCopyWithImpl<$Res>
    extends _$ErrorReportStateCopyWithImpl<$Res>
    implements $ErrorReportStateInitialCopyWith<$Res> {
  _$ErrorReportStateInitialCopyWithImpl(ErrorReportStateInitial _value,
      $Res Function(ErrorReportStateInitial) _then)
      : super(_value, (v) => _then(v as ErrorReportStateInitial));

  @override
  ErrorReportStateInitial get _value => super._value as ErrorReportStateInitial;
}

/// @nodoc

class _$ErrorReportStateInitial
    with DiagnosticableTreeMixin
    implements ErrorReportStateInitial {
  const _$ErrorReportStateInitial();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ErrorReportState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ErrorReportState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ErrorReportStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function() success,
    required TResult Function() emailUnsupported,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorReportStateInitial value) initial,
    required TResult Function(ErrorReportStateInProgress value) inProgress,
    required TResult Function(ErrorReportStateSuccess value) success,
    required TResult Function(ErrorReportStateEmailUnsupported value)
        emailUnsupported,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ErrorReportStateInitial implements ErrorReportState {
  const factory ErrorReportStateInitial() = _$ErrorReportStateInitial;
}

/// @nodoc
abstract class $ErrorReportStateInProgressCopyWith<$Res> {
  factory $ErrorReportStateInProgressCopyWith(ErrorReportStateInProgress value,
          $Res Function(ErrorReportStateInProgress) then) =
      _$ErrorReportStateInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorReportStateInProgressCopyWithImpl<$Res>
    extends _$ErrorReportStateCopyWithImpl<$Res>
    implements $ErrorReportStateInProgressCopyWith<$Res> {
  _$ErrorReportStateInProgressCopyWithImpl(ErrorReportStateInProgress _value,
      $Res Function(ErrorReportStateInProgress) _then)
      : super(_value, (v) => _then(v as ErrorReportStateInProgress));

  @override
  ErrorReportStateInProgress get _value =>
      super._value as ErrorReportStateInProgress;
}

/// @nodoc

class _$ErrorReportStateInProgress
    with DiagnosticableTreeMixin
    implements ErrorReportStateInProgress {
  const _$ErrorReportStateInProgress();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ErrorReportState.inProgress()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ErrorReportState.inProgress'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorReportStateInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function() success,
    required TResult Function() emailUnsupported,
  }) {
    return inProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
  }) {
    return inProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorReportStateInitial value) initial,
    required TResult Function(ErrorReportStateInProgress value) inProgress,
    required TResult Function(ErrorReportStateSuccess value) success,
    required TResult Function(ErrorReportStateEmailUnsupported value)
        emailUnsupported,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class ErrorReportStateInProgress implements ErrorReportState {
  const factory ErrorReportStateInProgress() = _$ErrorReportStateInProgress;
}

/// @nodoc
abstract class $ErrorReportStateSuccessCopyWith<$Res> {
  factory $ErrorReportStateSuccessCopyWith(ErrorReportStateSuccess value,
          $Res Function(ErrorReportStateSuccess) then) =
      _$ErrorReportStateSuccessCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorReportStateSuccessCopyWithImpl<$Res>
    extends _$ErrorReportStateCopyWithImpl<$Res>
    implements $ErrorReportStateSuccessCopyWith<$Res> {
  _$ErrorReportStateSuccessCopyWithImpl(ErrorReportStateSuccess _value,
      $Res Function(ErrorReportStateSuccess) _then)
      : super(_value, (v) => _then(v as ErrorReportStateSuccess));

  @override
  ErrorReportStateSuccess get _value => super._value as ErrorReportStateSuccess;
}

/// @nodoc

class _$ErrorReportStateSuccess
    with DiagnosticableTreeMixin
    implements ErrorReportStateSuccess {
  const _$ErrorReportStateSuccess();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ErrorReportState.success()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ErrorReportState.success'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ErrorReportStateSuccess);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function() success,
    required TResult Function() emailUnsupported,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorReportStateInitial value) initial,
    required TResult Function(ErrorReportStateInProgress value) inProgress,
    required TResult Function(ErrorReportStateSuccess value) success,
    required TResult Function(ErrorReportStateEmailUnsupported value)
        emailUnsupported,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class ErrorReportStateSuccess implements ErrorReportState {
  const factory ErrorReportStateSuccess() = _$ErrorReportStateSuccess;
}

/// @nodoc
abstract class $ErrorReportStateEmailUnsupportedCopyWith<$Res> {
  factory $ErrorReportStateEmailUnsupportedCopyWith(
          ErrorReportStateEmailUnsupported value,
          $Res Function(ErrorReportStateEmailUnsupported) then) =
      _$ErrorReportStateEmailUnsupportedCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorReportStateEmailUnsupportedCopyWithImpl<$Res>
    extends _$ErrorReportStateCopyWithImpl<$Res>
    implements $ErrorReportStateEmailUnsupportedCopyWith<$Res> {
  _$ErrorReportStateEmailUnsupportedCopyWithImpl(
      ErrorReportStateEmailUnsupported _value,
      $Res Function(ErrorReportStateEmailUnsupported) _then)
      : super(_value, (v) => _then(v as ErrorReportStateEmailUnsupported));

  @override
  ErrorReportStateEmailUnsupported get _value =>
      super._value as ErrorReportStateEmailUnsupported;
}

/// @nodoc

class _$ErrorReportStateEmailUnsupported
    with DiagnosticableTreeMixin
    implements ErrorReportStateEmailUnsupported {
  const _$ErrorReportStateEmailUnsupported();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ErrorReportState.emailUnsupported()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ErrorReportState.emailUnsupported'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorReportStateEmailUnsupported);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() inProgress,
    required TResult Function() success,
    required TResult Function() emailUnsupported,
  }) {
    return emailUnsupported();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
  }) {
    return emailUnsupported?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? inProgress,
    TResult Function()? success,
    TResult Function()? emailUnsupported,
    required TResult orElse(),
  }) {
    if (emailUnsupported != null) {
      return emailUnsupported();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorReportStateInitial value) initial,
    required TResult Function(ErrorReportStateInProgress value) inProgress,
    required TResult Function(ErrorReportStateSuccess value) success,
    required TResult Function(ErrorReportStateEmailUnsupported value)
        emailUnsupported,
  }) {
    return emailUnsupported(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
  }) {
    return emailUnsupported?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorReportStateInitial value)? initial,
    TResult Function(ErrorReportStateInProgress value)? inProgress,
    TResult Function(ErrorReportStateSuccess value)? success,
    TResult Function(ErrorReportStateEmailUnsupported value)? emailUnsupported,
    required TResult orElse(),
  }) {
    if (emailUnsupported != null) {
      return emailUnsupported(this);
    }
    return orElse();
  }
}

abstract class ErrorReportStateEmailUnsupported implements ErrorReportState {
  const factory ErrorReportStateEmailUnsupported() =
      _$ErrorReportStateEmailUnsupported;
}
